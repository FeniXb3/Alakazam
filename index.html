<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
        <script>
            mermaid.initialize({ startOnLoad: true });
        </script>

<div id="page-container" class="full-height">
    
    <div>
        
        <button id="redraw">Alakazam!</button>
        <button id="clear">Clear</button>
        <button id="save-svg">Save SVG file</button>
    </div>
    <div id="workspace">
        
        <div id="output"></div>
        
        
        <div id="flowchart-code-preview" rows="10" cols="60"></div>

        
    </div>    
</div>

        <script type="module">
            import {Flowchart, Node} from './alakazam.js';

            const flowchart = new Flowchart();
            flowchart.prepare();
            const redrawButton = document.getElementById('redraw');
            const clearButton = document.getElementById('clear');
            const workspace = document.getElementById('workspace');
            const output = document.getElementById('output');
            const previewContainer = document.getElementById('flowchart-code-preview');

            redrawButton.addEventListener('click', () =>{
                const flowchartCode = flowchart.generateCode();
                previewContainer.innerText = flowchartCode;
                mermaid.render('theGraph', flowchartCode, function(svgCode) {
                    output.innerHTML = svgCode;
                });
            });

            clearButton.addEventListener('click', () =>{
                previewContainer.innerText = ''; 
                output.innerHTML = '';
            });

            let startingNodeElement;
            let finishingNodeElement;
            workspace.addEventListener('mousedown', (event) => {
                event.preventDefault();
                const shouldReattachConnected = !event.getModifierState('Control');
                // const altPressed = event.getModifierState('Alt');
                // const shiftPressed = event.getModifierState('Shift');

                startingNodeElement = event.target.closest('.node');
                // if (!startingNodeElement || !startingNodeElement.classList.contains('node')) {
                //     return;
                // }

                
            });

            document.oncontextmenu = function() {
                return false;
            }
            // document.getElementsByTagName('body')[0].addEventListener('contextmenu', event => {return false;});
            
            workspace.addEventListener('mouseup', (event) => {
                const shouldReattachConnected = !event.getModifierState('Control');
                const shouldAddAlternativePath = event.getModifierState('Alt');
                // const shiftPressed = event.getModifierState('Shift');

                finishingNodeElement = event.target.closest('.node');
                

                if (!startingNodeElement) {
                    if (event.button == 0) {   
                        const nodeType = Flowchart.getNodeType();
                        if (nodeType == null) {
                            return;
                        }
                        const nodeDescription = Flowchart.getNodeDescription();
                        if (nodeDescription == null) {
                            return;
                        }
                        flowchart.addNode(nodeDescription, nodeType);
                    }
                } else if (finishingNodeElement == startingNodeElement || !finishingNodeElement ||!finishingNodeElement.classList.contains('node')) {
                    const startingNode = flowchart.findNodeByMermaidId(startingNodeElement.id);
                    
                    if (event.button == 2) {  
                        flowchart.removeNode(startingNode);
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    else if (event.button == 0) {       
                        const nodeType = Flowchart.getNodeType();
                        if (nodeType == null) {
                            return;
                        }
                        const nodeDescription = Flowchart.getNodeDescription();
                        if (nodeDescription == null) {
                            return;
                        }
                        let connectionDescription = '';
                        // startingNode.type == 'decision' 
                        //  ? Flowchart.getConnectionDescription()
                        //: '';
                        if (connectionDescription == null) {
                            return;
                            }

                            if (startingNode.type == 'decision') {
                            if (shouldAddAlternativePath) {
                                connectionDescription = 'No'
                                flowchart.addAlternateNode(startingNodeElement.id,nodeDescription, nodeType, connectionDescription);
                            } 
                            else {
                                connectionDescription = 'Yes'
                                flowchart.addNodeTo(startingNodeElement.id, shouldReattachConnected, nodeDescription, nodeType, connectionDescription);
                            }
                        }
                        else {
                            flowchart.addNodeTo(startingNodeElement.id, shouldReattachConnected, nodeDescription, nodeType, connectionDescription);
                        }
                    }
                }
                else {
                    const startingNode = flowchart.findNodeByMermaidId(startingNodeElement.id);
                    const finishingNode = flowchart.findNodeByMermaidId(finishingNodeElement.id);
                    let connectionDescription = '';
                    // startingNode.type == 'decision' 
                      //  ? Flowchart.getConnectionDescription()
                        //: '';
                    if (event.button == 2) {  
                        flowchart.removeConnection(startingNode, finishingNode);
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    else if (event.button == 0) {  
                        if (startingNode.type == 'decision') {
                            if (shouldAddAlternativePath) {
                                connectionDescription = 'No'
                                flowchart.connectAlternateNode(startingNodeElement.id, finishingNodeElement.id, connectionDescription);
                            } 
                            else {
                                connectionDescription = 'Yes'
                                flowchart.connectAlternateNode(startingNodeElement.id, finishingNodeElement.id, connectionDescription);
                                // flowchart.connectNodes(startingNodeElement.id, finishingNodeElement.id, shouldReattachConnected, connectionDescription);
                            }
                        }
                        else {
                            flowchart.connectNodes(startingNodeElement.id, finishingNodeElement.id, shouldReattachConnected, connectionDescription);
                        }
                    }
                }

                redrawButton.click();
            });

            redrawButton.click();
            
            const svgElement = document.getElementById('theGraph');
            const saveSvgButton = document.getElementById('save-svg');
            function saveSvg(svgEl, name) {
                svgEl.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                var svgData = svgEl.outerHTML;
                var preface = '<?xml version="1.0" standalone="no"?>\r\n';
                var svgBlob = new Blob([preface, svgData], {type:"image/svg+xml;charset=utf-8"});
                var svgUrl = URL.createObjectURL(svgBlob);
                var downloadLink = document.createElement("a");
                downloadLink.href = svgUrl;
                downloadLink.download = name;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            }
            
            saveSvgButton.addEventListener('click', event => {
                const fileName = prompt('Choose file name', 'alakazam');
                if (fileName == null) {
                    return;
                }

                saveSvg(svgElement, `${fileName}.svg`);
            });
            
        </script>
       
    </body>
</html>